---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 54237.
--- DateTime: 2020/5/29 22:26
---
local UIManager = {}
local UICfg = require("Constant/UIConfig")
ScreenBase = require ("UIFrameWork/ScreenBase/ScreenBase")
SubScreenBase = require ("UIFrameWork/ScreenBase/SubScreenBase")
MaskScreenManager = require ("UIFrameWork/MaskScreenManager")

function UIManager:Create()
    self:InitVar()
    self:Init()
    self:InitUIPool()
    return self
end

function UIManager:InitVar()
    self.uiRoot = nil
    self.poolRoot = nil
    self.uiCamera = nil
    self.sortTemp = nil --处理界面排序
    self.typeScreens = {}
    self.uiOpenOrder = 0 --UI打开时的Order值 用来标识界面层级顺序
    self.ScreenResolutionX = 1136
    self.ScreenResolutionY = 640
end

function UIManager:Init()
    self.go = GameObject("UIManager");
    self.transform = self.go.transform
    self.transform:SetParent(GameObject.Find("BootObj").transform)--挂接到BootObj下
    self.uiRoot = GameObject.Instantiate(Resources.Load("UIRoot"), self.transform)
    self.uiCamera = self.uiRoot:GetComponent(typeof(Canvas)).worldCamera;
end

--初始化UI缓存池
function UIManager:InitUIPool()
    local poolRoot = GameObject("UIPoolRoot");
    poolRoot.transform:SetParent(self.transform);

    local canvas = poolRoot:AddComponent(typeof(Canvas));
    canvas.enabled = false;
end

--// 预制分辨率
function UIManager:Update()
    if self.ScreenResolutionX ~= Screen.width or self.ScreenResolutionY ~= Screen.height then
        self.ScreenResolutionX = Screen.width
        self.ScreenResolutionY = Screen.height
        EventManager.ScreenResolutionEvt:BroadCastEvent(self.ScreenResolutionX,self.ScreenResolutionY);
    end
end

-- UI打开入口没有判断条件直接打开
function UIManager:OpenUI(uiName,data)
    local uiConfig = self:GetConfig(uiName)
    if not uiConfig then
        ELog("uiConfig 未添加 "..uiName)
        return
    end
    local ui = self:GetUI(uiName)
    self.uiOpenOrder = self.uiOpenOrder + 1
    if ui then
        if ui:GetCtrlBase() and not ui:GetCtrlBase().ctrlCanvas.enabled then
            ui:GetCtrlBase().ctrlCanvas.enabled = true
        end
        ui:Show()
    else
        ui = require(uiConfig.luaPath).New(uiConfig.uiResPath,uiName,data) --界面是唯一的，单例
        self.typeScreens[uiName] = ui
        ui:SetOpenOrder(self.uiOpenOrder) --设置打开序号
    end
    --ui:Show() --同步放这没问题，异步的话这个会在Create之前，所以需要换个位置
    if ui:GetCtrlBase().mHideOtherScreenWhenThisOnTop then
        self:ProcessUIOnTop();
    end
    return ui
end

function UIManager:GetConfig(name)
    local config = UICfg[name]
    return config
end

--UI外部调用的获取接口
function UIManager:GetUI(uiName)
    return self.typeScreens[uiName]
end

function UIManager:CloseUI(uiName)
    local ui = self:GetUI(uiName);
    if ui then
        ui:Close();
        return true;
    end
    return false;
end

function UIManager:CloseAllUI()
    local forScreens = DeepCopy(self.typeScreens)
    for uiName, inst in pairs(forScreens) do
        inst:Close()
    end
end

--UI创建时候自动处理的UI打开处理 一般不要手动调用
function UIManager:AddUI(sBase)
    sBase:GetPanelRoot().transform:SetParent(self:GetUIRootTransform())
    sBase:GetPanelRoot().transform.localPosition = Vector3.zero
    sBase:GetPanelRoot().transform.localScale = Vector3.one
    sBase:GetPanelRoot().transform.localRotation = Quaternion.identity
    sBase:GetPanelRoot().name = string.gsub(sBase:GetPanelRoot().name,"[(]Clone[)]","")
    sBase:Show()
end

function UIManager:RemoveUI(uiName)
    local ui = self:GetUI(uiName)
    -- 根据具体需求决定到底是直接销毁还是缓存
    if ui then
        self.typeScreens[uiName] = nil
        ui:Dispose();

        if ui:GetCtrlBase().mHideOtherScreenWhenThisOnTop then
            self:ProcessUIOnTop();
        end
    end
end

function UIManager:ProcessUIOnTop()
    self:SortUIOrder();
    --先找到第一个控制的UI层
    local index = 0
    for idx, ui in ipairs(self.sortTemp) do
        if ui:GetCtrlBase().mHideOtherScreenWhenThisOnTop then
            ui:GetCtrlBase().ctrlCanvas.enabled = true
            index = idx --因为是一个有序的List 所以找到第一个需要控制的界面之后记录序号，然后从它接着遍历即可
            break
        end
    end
    if index == 0 then --如果没有找到 可能的情况是就是关闭了最上层界面 所以现在最上层的应该是空的
        for idx, ui in ipairs(self.sortTemp) do
            if not ui:GetCtrlBase().ctrlCanvas.enabled then
                ui:GetCtrlBase().ctrlCanvas.enabled = true;
                index = idx --因为是一个有序的List 所以找到第一个需要控制的界面之后记录序号，然后从它接着遍历即可
                break
            end
        end
    end
    --找到下面需要隐藏的
    for i = index + 1, #self.sortTemp do
        local ui = self.sortTemp[i]
        if not ui:GetCtrlBase().mAlwaysShow then
            -- 找到需要被隐藏的界面 隐藏就好
            ui:GetCtrlBase().ctrlCanvas.enabled = false;
        end
    end
end


function UIManager:SortUIOrder()
    local sortTemp = {}
    for _ , ui in pairs(self.typeScreens) do
        table.insert(sortTemp,ui)
    end
    table.sort(sortTemp,function (a,b)
        if a:GetSortingLayer() == b:GetSortingLayer() then
            return b:GetOpenOrder() < a:GetOpenOrder()
        else
            return b:GetSortingLayer() < a:GetSortingLayer()
        end
    end)
    self.sortTemp = sortTemp
end
------------通用API------------
--获取UIRoot节点
function UIManager:GetUIRootTransform()
    return self.transform;
end

function UIManager:GetUICamera()
    return self.uiCamera;
end

return UIManager